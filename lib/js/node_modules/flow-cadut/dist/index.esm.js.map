{"version":3,"file":"index.esm.js","sources":["../src/env.js","../src/strings.js","../src/file.js","../src/imports.js","../src/parser.js","../src/type-checker.js","../src/args.js","../src/fixer.js","../src/processor.js","../src/interactions.js"],"sourcesContent":["/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { config } from \"@onflow/config\";\n\nexport const DEPLOYED_CONTRACTS = {\n  emulator: {\n    FlowToken: \"0xee82856bf20e2aa6\",\n    FungibleToken: \"0x0ae53cb6e3f42a79\",\n  },\n  testnet: {\n    FlowToken: \"0x7e60df042a9c0868\",\n    FungibleToken: \"0x9a0766d93b6608b7\",\n    LockedTokens: \"0x95e019a17d0e23d7\",\n    StakingProxy: \"0x7aad92e5a0715d21\",\n  },\n  mainnet: {\n    FlowToken: \"0x1654653399040a61\",\n    FungibleToken: \"0xf233dcee88fe0abe\",\n    LockedTokens: \"0x8d0e87b65159ae63\",\n    StakingProxy: \"0x62430cf28c26d095\",\n  },\n};\n\nexport const ACCESS_NODES = {\n  mainnet: \"https://access.mainnet.onflow.org\",\n  testnet: \"https://access-testnet.onflow.org\",\n  emulator: \"http://localhost:8080\",\n};\n\nexport const getEnvironment = async () => {\n  const env = (await config().get(\"ix.env\")) || \"emulator\";\n  return DEPLOYED_CONTRACTS[env] || DEPLOYED_CONTRACTS.emulator;\n};\n\nexport const setEnvironment = async (networkName = \"emulator\", options = {}) => {\n  const network = networkName.toLowerCase();\n\n  if (!DEPLOYED_CONTRACTS[network]) {\n    throw new Error(\n      `Provided value \"${network}\" is not supported. Try \"emulator\", \"testnet\" or \"mainnet\". Default: \"emulator\"`\n    );\n  }\n\n  const { port, endpoint } = options;\n  const portBased =\n    network === \"emulator\" && port ? `http://localhost:${port}` : ACCESS_NODES[network];\n  const accessNode = endpoint || portBased;\n\n  await config().put(\"ix.env\", network);\n  await config().put(\"accessNode.api\", accessNode);\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const capitalizeFirstLetter = (input) => {\n  const [first] = input.split(\"\");\n  return first.toUpperCase() + input.slice(1);\n};\n\nexport const underscoreToCamelCase = (text) => {\n  return text\n    .replace(/-/g, \"_\")\n    .split(\"_\")\n    .map((word, i) => (i > 0 ? capitalizeFirstLetter(word) : word))\n    .join(\"\");\n};\n\nexport const trimAndSplit = (input, trimWith, splitBy) => {\n  if (splitBy) {\n    return input.replace(trimWith, \"\").split(splitBy);\n  }\n  return input.replace(trimWith, \"\").split(getSplitCharacter(input));\n};\n\nexport const getSplitCharacter = (input) => {\n  switch (true) {\n    case input.indexOf(\"//\") >= 0:\n      return \"//\";\n    case input.indexOf(\"/\") >= 0:\n      return \"/\";\n    case input.indexOf(\"\\\\\") >= 0:\n      return \"\\\\\";\n    default:\n      return \"\";\n  }\n};\n\nexport const collapseSpaces = (input) => input.replace(/\\s+/g, \" \");\nexport const removeSpaces = (input) => input.replace(/\\s+/g, \"\");\nexport const stripNewLines = (input) => input.replace(/\\r\\n|\\n|\\r/g, \" \");\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from \"fs\";\nimport { resolve, dirname } from \"path\";\nimport prettier from \"prettier\";\nimport parserBabel from \"prettier/parser-babel\";\nimport { underscoreToCamelCase } from \"./strings\";\n\n/**\n * Syntax sugar for file reading\n * @param {string} path - path to file to be read\n */\nexport const readFile = (path) => {\n  return fs.readFileSync(path, \"utf8\");\n};\n\n/**\n * Syntax sugar for file writing\n * @param {string} path - path to file to be read\n * @param {string} data - data to write into file\n */\nexport const writeFile = (path, data) => {\n  const targetDir = dirname(path);\n  fs.mkdirSync(targetDir, { recursive: true });\n  return fs.writeFileSync(path, data, { encoding: \"utf8\" });\n};\n\n/**\n * Syntax sugar for removing directory and all it's contents\n * @param {string} path - path to directory to delete\n */\nexport const clearPath = (path) => {\n  fs.rmdirSync(path, { recursive: true });\n};\n\nexport const getFilesList = async (dir) => {\n  const dirents = await fs.promises.readdir(dir, { withFileTypes: true });\n  const files = await Promise.all(\n    dirents.map((dirent) => {\n      const res = resolve(dir, dirent.name);\n      return dirent.isDirectory() ? getFilesList(res) : res;\n    })\n  );\n  return files.flat();\n};\n\nexport const sansExtension = (fileName) => {\n  return fileName.replace(/\\..*/, \"\");\n};\n\nexport const prettify = (code, props) => {\n  // Use the same formatting options as in this repository\n  // TODO: read prettier config from local folder\n  const options = {\n    printWidth: 100,\n    endOfLine: \"lf\",\n    semi: true,\n    useTabs: false,\n    singleQuote: false,\n    trailingComma: \"es5\",\n    tabWidth: 2,\n    ...props\n  };\n  return prettier.format(code, { parser: \"babel\", plugins: [parserBabel], ...options });\n};\n\nexport const generateExports = async (dir, template) => {\n  const entities = await fs.promises.readdir(dir, { withFileTypes: true });\n\n  const currentFolder = entities.reduce(\n    (acc, entity) => {\n      if (entity.isDirectory()) {\n        acc.folders.push(entity);\n        acc.folderNames.push(entity.name);\n      } else {\n        const camelCased = underscoreToCamelCase(entity.name);\n        const fileName = sansExtension(camelCased);\n\n        const contractPragma = \"/** pragma type contract **/\";\n\n        if (entity.isFile()) {\n          const filePath = resolve(dir, entity.name);\n          const content = fs.readFileSync(filePath, \"utf8\");\n          if (content.includes(contractPragma)) {\n            acc.contracts.push(fileName);\n          } else {\n            acc.files.push(fileName);\n          }\n        }\n      }\n      return acc;\n    },\n    { folderNames: [], folders: [], files: [], contracts: [] }\n  );\n\n  currentFolder.name = dir;\n  const packageData = template({\n    folders: currentFolder.folderNames,\n    files: currentFolder.files,\n    contracts: currentFolder.contracts,\n  });\n  writeFile(`${dir}/index.js`, prettify(packageData));\n\n  await Promise.all(\n    currentFolder.folders.map((dirent) => {\n      const res = resolve(dir, dirent.name);\n      return dirent.isDirectory() ? generateExports(res, template) : res;\n    })\n  );\n\n  return currentFolder;\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst getPairs = (line) => {\n  return line\n    .split(/\\s/)\n    .map((item) => item.replace(/\\s/g, \"\"))\n    .filter((item) => item.length > 0 && item !== \"import\" && item !== \"from\");\n};\n\nconst collect = (acc, item) => {\n  const [contract, address] = item;\n  acc[contract] = address;\n  return acc;\n};\n\n/**\n * Returns address map for contracts defined in template code.\n * @param {string} code - Cadence code to parse.\n * @returns {*}\n */\nexport const extractImports = (code) => {\n  if (!code || code.length === 0) {\n    return {};\n  }\n  return code\n    .split(\"\\n\")\n    .filter((line) => line.includes(\"import\"))\n    .map(getPairs)\n    .reduce(collect, {});\n};\n\n/**\n * Returns list of missing imports.\n * @param {string} code - template cadence code\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const missingImports = (code, addressMap = {}) => {\n  const importsList = extractImports(code);\n  const missing = [];\n\n  for (const key in importsList) {\n    if (!addressMap[key] && Object.prototype.hasOwnProperty.call(importsList, key)) {\n      missing.push(key);\n    }\n  }\n\n  return missing;\n};\n\n/**\n * Reports missing imports.\n * @param {Array.<string>} list - list of missing imports\n * @param {string} prefix - error message prefix\n */\nexport const report = (list = [], prefix = \"\") => {\n  const errorMessage = `Missing imports for contracts:`;\n  const message = prefix ? `${prefix} ${errorMessage}` : errorMessage;\n  console.error(message, list);\n};\n\n/**\n * Reports missing imports.\n * @param {string} code - template cadence code\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param {string} [prefix] - prefix to add to error message\n */\nexport const reportMissingImports = (code, addressMap, prefix = \"\") => {\n  const list = missingImports(code, addressMap);\n  if (list.length > 0) {\n    report(list, prefix);\n  }\n};\n\nconst REGEXP_IMPORT = /(\\s*import\\s*)([\\w\\d]+)(\\s+from\\s*)([\\w\\d\".\\\\/]+)/g;\n\n/**\n * Returns Cadence template code with replaced import addresses\n * @param {string} code - Cadence template code.\n * @param {{string:string}} [addressMap={}] - name/address map or function to use as lookup table\n * for addresses in import statements.\n * @param byName - lag to indicate whether we shall use names of the contracts.\n * @returns {*}\n */\nexport const replaceImportAddresses = (code, addressMap, byName = true) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract, _, address) => {\n    const key = byName ? contract : address;\n    const newAddress = addressMap instanceof Function ? addressMap(key) : addressMap[key];\n    return `${imp}${contract} from ${newAddress}`;\n  });\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { collapseSpaces } from \"./strings\";\n\nexport const CONTRACT = \"contract\";\nexport const TRANSACTION = \"transaction\";\nexport const SCRIPT = \"script\";\nexport const UNKNOWN = \"unknown\";\n\n\nexport const extract = (code, keyWord) => {\n  const target = collapseSpaces(code.replace(/[\\n\\r]/g, \"\"))\n\n  if (target) {\n    const regexp = new RegExp(keyWord, \"g\")\n    const match = regexp.exec(target);\n\n    if (match) {\n      if (match[1] === \"\") {\n        return [];\n      }\n      return match[1]\n        .split(\",\")\n        .map((item) => item.replace(/\\s*/g, \"\"))\n        .filter(item => item !== \"\")\n    }\n  }\n  return [];\n};\n\nexport const extractSigners = (code) => {\n  return extract(code, `(?:prepare\\\\s*\\\\(\\\\s*)([^\\\\)]*)(?:\\\\))`);\n};\n\nexport const extractScriptArguments = (code) => {\n  return extract(code, `(?:fun\\\\s+main\\\\s*\\\\(\\\\s*)([^\\\\)]*)(?:\\\\))`);\n};\n\nexport const extractTransactionArguments = (code) => {\n  return extract(code, `(?:transaction\\\\s*\\\\(\\\\s*)([^\\\\)]*)(?:\\\\))`);\n};\n\nexport const extractContractName = (code) => {\n  const contractNameMatcher = /\\w+\\s+contract\\s+(?:interface)*\\s*(\\w*)/g;\n  const singleLine = code.replace(/\\r\\n|\\n|\\r/g, \" \");\n  const matches = contractNameMatcher.exec(singleLine);\n\n  if (matches.length < 2) {\n    throw new Error(\"Contract Error: can't find name of the contract\");\n  }\n\n  return matches[1];\n};\n\nexport const getTemplateInfo = (code) => {\n  const contractMatcher = /\\w+\\s+contract\\s+(\\w*\\s*)\\w*/g;\n  const transactionMatcher = /transaction\\s*(\\(\\s*\\))*\\s*/g;\n  const scriptMatcher = /pub\\s+fun\\s+main\\s*/g;\n\n  if (transactionMatcher.test(code)) {\n    const signers = extractSigners(code);\n    const args = extractTransactionArguments(code);\n    return {\n      type: TRANSACTION,\n      signers: signers.length,\n      args: args,\n    };\n  }\n\n  if (scriptMatcher.test(code)) {\n    const args = extractScriptArguments(code);\n    return {\n      type: SCRIPT,\n      args: args,\n    };\n  }\n\n  if (contractMatcher.test(code)) {\n    // TODO: implement extraction from `init` method\n    const contractName = extractContractName(code);\n    return {\n      type: CONTRACT,\n      signers: 1,\n      args: [],\n      contractName,\n    };\n  }\n\n  return {\n    type: UNKNOWN,\n  };\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const wrongType = (type) => !type || typeof type != \"string\";\n\nexport const isBasicNumType = (type) => {\n  if (wrongType(type)) return false;\n  return type.startsWith(\"Int\") || type.startsWith(\"UInt\") || type.startsWith(\"Word\");\n};\n\nexport const isFixedNumType = (type) => {\n  if (wrongType(type)) return false;\n  return type.startsWith(\"Fix64\") || type.startsWith(\"UFix64\");\n};\n\nexport const isString = (type) => type === \"String\";\nexport const isCharacter = (type) => type === \"Character\";\nexport const isBoolean = (type) => type === \"Bool\";\nexport const isAddress = (type) => type === \"Address\" || type === \"Address?\";\n\nexport const isBasicType = (type) => {\n  if (wrongType(type)) return false;\n\n  let fixedType = type.endsWith(\"?\") ? type.slice(0, -1) : type;\n  return (\n    isBasicNumType(fixedType) ||\n    isString(fixedType) ||\n    isCharacter(fixedType) ||\n    isBoolean(fixedType)\n  );\n};\n\nexport const isArray = (type) => {\n  if (wrongType(type)) return false;\n\n  const clearType = type.replace(/\\s/g, \"\");\n  return clearType.startsWith(\"[\") && clearType.endsWith(\"]\");\n};\n\nexport const isDictionary = (type) => {\n  if (wrongType(type)) return false;\n\n  const clearType = type.replace(/\\s/g, \"\");\n  return clearType.startsWith(\"{\") && clearType.endsWith(\"}\");\n};\n\nexport const isComplexType = (type) => isArray(type) || isDictionary(type);\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as t from \"@onflow/types\";\nimport * as fcl from \"@onflow/fcl\";\n\nimport { toFixedValue, withPrefix } from \"./fixer\";\nimport { getTemplateInfo } from \"./parser\";\nimport {\n  isBasicType,\n  isFixedNumType,\n  isAddress,\n  isArray,\n  isDictionary,\n  isComplexType,\n  wrongType,\n} from \"./type-checker\";\n\nimport { removeSpaces } from \"./strings\";\n\nconst throwTypeError = (msg) => {\n  throw new Error(\"Type Error: \" + msg);\n};\n\nexport const splitArgs = (pair) => {\n  return pair\n    .split(/(\\w+)\\s*:\\s*([\\w{}[\\]:\\s?]*)/)\n    .filter((item) => item !== \"\")\n    .map((item) => item.replace(/\\s*/g, \"\"));\n};\n\nexport const argType = (pair) => splitArgs(pair)[1];\n\nexport const getDictionaryTypes = (type) => {\n  const match = /{(.*)}/.exec(type);\n  return match[1]\n    .split(/([^:]*):(.*)/)\n    .map((item) => item.replace(/\\s/g, \"\"))\n    .filter((item) => item);\n};\n\nexport const getArrayType = (type) => {\n  const match = /\\[(.*)\\]/.exec(type);\n  return removeSpaces(match[1]);\n};\n\n/**\n * Reports missing arguments.\n * @param {number} found - number of arguments passed into method\n * @param {number} required - number of arguments required to execute the code\n * @param {string} prefix - error message prefix\n */\nexport const reportArguments = (found, required, prefix = \"\") => {\n  if (required > found) {\n    const errorMessage = `Incorrect number of arguments: found ${found} of ${required}`;\n    const message = prefix ? `${prefix} ${errorMessage}` : errorMessage;\n    console.error(message);\n  }\n};\n\n/**\n * Reports missing items.\n * @param {string} itemType - name of the missing item\n * @param {number} found - number of arguments passed into method\n * @param {number} required - number of arguments required to execute the code\n * @param {string} prefix - error message prefix\n */\nexport const reportMissing = (itemType = \"items\", found, required, prefix = \"\") => {\n  if (required > found) {\n    const errorMessage = `Incorrect number of ${itemType}: found ${found} of ${required}`;\n    const message = prefix ? `${prefix} ${errorMessage}` : errorMessage;\n    console.error(message);\n  }\n};\n\nexport const raw = (type) => type.slice(0, -1);\n\nexport const resolveBasicType = (type) => {\n  if (wrongType(type)) return false;\n\n  if (type.includes(\"?\")) {\n    return t.Optional(t[raw(type)]);\n  }\n  return t[type];\n};\n\nexport const resolveType = (type) => {\n  if (isComplexType(type)) {\n    switch (true) {\n      case isArray(type): {\n        const arrayType = getArrayType(type);\n        let finalType = resolveBasicType(arrayType);\n        if (isArray(arrayType)) {\n          finalType = resolveType(arrayType);\n        }\n        return t.Array(finalType);\n      }\n      default: {\n        return resolveBasicType(type);\n      }\n    }\n  }\n  return resolveBasicType(type);\n};\n\n/**\n * Map single argument to fcl.arg representation.\n * @param {string} type - Cadence value type\n * @param {any} value - actual value\n * @returns any - mapped fcl.arg value\n */\nexport const mapArgument = (type, value) => {\n  const resolvedType = resolveType(type);\n\n  switch (true) {\n    case isBasicType(type): {\n      return fcl.arg(value, resolvedType);\n    }\n\n    case isFixedNumType(type): {\n      // Try to parse value and throw if it fails\n      if (value === null) {\n        return fcl.arg(null, resolvedType);\n      }\n      if (isNaN(parseFloat(value))) {\n        throwTypeError(\"Expected proper value for fixed type\");\n      }\n      return fcl.arg(toFixedValue(value), resolvedType);\n    }\n\n    case isAddress(type): {\n      const prefixedAddress = withPrefix(value);\n      return fcl.arg(prefixedAddress, resolvedType);\n    }\n\n    case isArray(type): {\n      const arrayType = getArrayType(type);\n\n      if (isComplexType(arrayType)) {\n        return fcl.arg(\n          value,\n          // value.map((v) => mapArgument(arrayType, v)),\n          resolvedType\n        );\n      }\n      return fcl.arg(value, resolvedType);\n    }\n\n    case isDictionary(type): {\n      const [keyType, valueType] = getDictionaryTypes(type);\n      const finalValue = [];\n      const keys = Object.keys(value);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        let resolvedValue;\n        if (isComplexType(valueType)) {\n          resolvedValue = mapArgument(valueType, value[key]);\n        } else {\n          resolvedValue = value[key];\n        }\n\n        finalValue.push({\n          key,\n          value: resolvedValue,\n        });\n      }\n      const resolvedKeyType = resolveType(keyType);\n      const resolvedValueType = resolveType(valueType);\n      return fcl.arg(finalValue, t.Dictionary({ key: resolvedKeyType, value: resolvedValueType }));\n    }\n\n    default: {\n      throw `${type} is not supported`;\n    }\n  }\n};\n\nexport const assertType = (arg) => arg.xform.asArgument(arg.value);\n\n/**\n * Map arguments with provided schema.\n * @param {[string]} schema - array of Cadence value types\n * @param {[any]} values - array of passed values\n * @returns [any] - array of mapped fcl.arg values\n */\nexport const mapArguments = (schema = [], values) => {\n  if (values.length < schema.length) {\n    throw new Error(\"Not enough arguments\");\n  }\n  return values.map((value, i) => {\n    const mapped = mapArgument(schema[i], value);\n    assertType(mapped);\n    return mapped;\n  });\n};\n\n/**\n * Map arguments via Cadence template.\n * @param {string} code - Cadence template\n * @param {[any]} values - array of values\n * @returns [any] - array of mapped fcl.arg\n */\nexport const mapValuesToCode = (code, values = []) => {\n  const schema = getTemplateInfo(code).args.map(argType);\n  return mapArguments(schema, values);\n};\n\nexport const unwrap = (arr, convert) => {\n  const type = arr[arr.length - 1];\n  return arr.slice(0, -1).map((value) => convert(value, type));\n};\n\nconst rawArgs = (args) => {\n  return args.reduce((acc, arg) => {\n    const unwrapped = unwrap(arg, (value, type) => {\n      return fcl.arg(value, type);\n    });\n    acc = [...acc, ...unwrapped];\n    return acc;\n  }, []);\n};\n\nexport const resolveArguments = (args, code) => {\n  if (args.length === 0) {\n    return [];\n  }\n\n  // We can check first element in array. If it's last value is instance\n  // of @onflow/types then we assume that the rest of them are also unprocessed\n  const first = args[0];\n  if (Array.isArray(first)) {\n    const last = first[first.length - 1];\n    if (last.asArgument) {\n      return rawArgs(args);\n    }\n  }\n  // Otherwise we process them and try to match them against the code\n  return mapValuesToCode(code, args);\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const sansPrefix = (address) => {\n  if (address == null) return null;\n  return address.replace(/^0x/, \"\");\n};\n\nexport const withPrefix = (address) => {\n  if (address == null) return null;\n  return \"0x\" + sansPrefix(address);\n};\n\nexport const padAddress = (address) => {\n  return \"0x\" + sansPrefix(address).padStart(16, \"0\");\n};\n\nexport const toFixedValue = (val) => parseFloat(val).toFixed(8);\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport { resolve } from \"path\";\nimport Handlebars from \"handlebars\";\nimport simpleGit from \"simple-git\";\n\nimport { getSplitCharacter, trimAndSplit, underscoreToCamelCase } from \"./strings\";\nimport { generateExports, getFilesList, readFile, writeFile } from \"./file\";\nimport { getTemplateInfo, CONTRACT, SCRIPT, TRANSACTION, extractSigners } from \"./parser\";\n\nconst getFetchUrl = (input) => {\n  // eslint-disable-next-line no-useless-escape\n  const groups = /(\\w+:\\/\\/)(.+@)*([\\w\\d\\.]+)(:[\\d]+)?\\/*(.*)/g.exec(input);\n\n  const inputPath = groups[5];\n  const inputBits = inputPath.split(\"/\");\n\n  const [owner, repo] = inputBits;\n  // TODO: use actual path with password and user\n  return `https://github.com/${owner}/${repo}`;\n};\n\nconst TEMP_REPO_FOLDER = path.resolve(process.cwd(), \"./temp-generator-repo\");\nconst clean = () => {\n  if (fs.existsSync(TEMP_REPO_FOLDER)) {\n    fs.rmdirSync(TEMP_REPO_FOLDER, { recursive: true });\n  }\n};\n\nexport const getBranchesList = (branches, remotes) => {\n  const mappedRemotes = remotes.map((item) => item.name);\n\n  return branches.map((branch) => {\n    for (let i = 0; i < mappedRemotes.length; i++) {\n      const remote = mappedRemotes[i];\n      const suffix = `remotes/${remote}/`;\n      if (branch.startsWith(suffix)) {\n        const sliceLength = suffix.length;\n        return branch.slice(sliceLength);\n      }\n    }\n    return branch;\n  });\n};\n\nexport const getParamsFromUrl = (url, branches) => {\n  for (let i = 0; i < branches.length; i++) {\n    const branch = branches[i];\n    const part = `tree/${branch}/`;\n    const index = url.indexOf(part);\n    if (index >= 0) {\n      return {\n        branch,\n        fetchUrl: url.slice(0, index - 1),\n        folderPath: `./${url.slice(index + part.length)}`,\n      };\n    }\n  }\n  return {\n    fetchUrl: url,\n    folderPath: \"./\",\n  };\n};\n\nexport const processGitRepo = async (input, output, branch, cliOptions = {}) => {\n  const git = simpleGit({\n    baseDir: process.cwd(),\n    binary: \"git\",\n  });\n\n  const fetchUrl = getFetchUrl(input);\n\n  console.log(\"Preparing space\");\n  clean();\n\n  const options = [];\n\n  console.log(`Cloning ${fetchUrl} repository to local machine`);\n  await git.clone(fetchUrl, TEMP_REPO_FOLDER, options);\n\n  const tempGit = simpleGit({\n    baseDir: TEMP_REPO_FOLDER,\n    binary: \"git\",\n  });\n\n  console.log(\"Extracting branch name and folder path from url\");\n  const branchList = await tempGit.branch([\"--list\", \"--all\"]);\n  const remotes = await tempGit.getRemotes();\n  const branches = getBranchesList(branchList.all, remotes);\n  const params = getParamsFromUrl(input, branches);\n\n  if (params.branch) {\n    console.log(`Branch name: ${params.branch}`);\n    console.log(`Check out ${params.branch} branch`);\n    tempGit.checkout(params.branch);\n  }\n\n  console.log(\"Processing Cadence template files\");\n  await processFolder(`${TEMP_REPO_FOLDER}/${params.folderPath}`, output, cliOptions);\n\n  // Teardown\n  console.log(\"Cleaning up\");\n  clean();\n\n  console.log(\"Done!\");\n};\n\nexport const processFolder = async (input, output, options = {}) => {\n  const splitCharacter = getSplitCharacter(input);\n  const fullBasePath = `${resolve(input)}${splitCharacter}`;\n  const fileList = await getFilesList(input);\n\n  for (let i = 0; i < fileList.length; i++) {\n    const path = fileList[i];\n\n    // Skip all but Cadence template files\n    if (!path.endsWith(\".cdc\")) {\n      continue;\n    }\n\n    const packages = trimAndSplit(path, fullBasePath);\n    const pathPackages = packages.slice(0, -1);\n    const file = packages.slice(-1)[0];\n\n    const ixDependency = options.dependency || \"flow-cadut\";\n\n    const code = readFile(path).replace(/`/g, \"'\");\n    const name = underscoreToCamelCase(file.replace(\".cdc\", \"\"));\n\n    const templateInfo = getTemplateInfo(code);\n\n    let argsAmount = 0;\n    if (templateInfo.args) {\n      argsAmount = templateInfo.args.length;\n    }\n\n    let data;\n    switch (templateInfo.type) {\n      case SCRIPT:\n        data = Handlebars.templates.script({\n          code,\n          name,\n          ixDependency,\n          argsAmount,\n          assetName: name,\n        });\n        break;\n      case TRANSACTION: {\n        const signers = extractSigners(code);\n        data = Handlebars.templates.transaction({\n          code,\n          name,\n          ixDependency,\n          argsAmount,\n          signersAmount: signers.length,\n          assetName: name,\n        });\n        break;\n      }\n      case CONTRACT: {\n        const contractName = templateInfo.contractName;\n        data = Handlebars.templates.contract({\n          code,\n          name,\n          ixDependency,\n          contractName,\n          assetName: name,\n        });\n        break;\n      }\n      default:\n        // TODO: implement empty plug\n        data = \"// Unsupported file\";\n    }\n\n    const templateFolder = pathPackages.join(`/`);\n    const filePath = `${output}/${templateFolder}/${name}.js`;\n\n    writeFile(filePath, data);\n  }\n\n  // Generate index.js exports in each folder\n  await generateExports(output, Handlebars.templates.package);\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fcl from \"@onflow/fcl\";\nimport { resolveArguments } from \"./args\";\nimport { replaceImportAddresses } from \"./imports\";\n\nexport const prepareInteraction = async (props, type) => {\n  const { code, args, addressMap, limit } = props;\n\n  const ixCode = replaceImportAddresses(code, addressMap);\n  const ixLimit = limit || 100;\n\n  const ix = type === \"script\" ? [fcl.script(ixCode)] : [fcl.transaction(ixCode)];\n\n  if (args) {\n    ix.push(fcl.args(resolveArguments(args, code)));\n  }\n\n  ix.push(fcl.limit(ixLimit));\n\n  if (type === \"transaction\") {\n    const { proposer, payer, signers = [] } = props;\n    const ixSigners = signers.length === 0 ? [payer] : signers;\n    const ixProposer = proposer || payer;\n\n    ix.push(fcl.payer(payer));\n    ix.push(fcl.proposer(ixProposer));\n    ix.push(fcl.authorizations(ixSigners));\n  }\n\n  return fcl.send(ix);\n};\n\n/**\n * Sends script code for execution.\n * Returns decoded value.\n */\n\nexport const executeScript = async (props) => {\n  try {\n    const response = await prepareInteraction(props, \"script\");\n    const result = await fcl.decode(response);\n    return [result, null];\n  } catch (e) {\n    return [null, e.message];\n  }\n};\n\n/**\n * Submits transaction to emulator network and waits before it will be sealed.\n * Returns transaction result.\n */\nexport const sendTransaction = async (props, waitForSeal = true) => {\n  try {\n    const response = await prepareInteraction(props, \"transaction\");\n    if (waitForSeal) {\n      const txResult = await fcl.tx(response).onceSealed();\n      return [txResult, null];\n    }\n    return [response, null];\n  } catch (e) {\n    return [null, e.message];\n  }\n};\n\n// TODO: add arguments for \"init\" method into template\nexport const addContractTemplate = `\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  `;\nexport const updateContractTemplate = `\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n`;\n\n// TODO: add jsdoc\nexport const hexContract = (contract) => Buffer.from(contract, \"utf8\").toString(\"hex\");\n\nexport const deployContract = async (props) => {\n  const { name, to, payer, proposer, update = false, code: contractCode } = props;\n\n  // TODO: Implement arguments for \"init\" method\n  const template = update ? addContractTemplate : updateContractTemplate;\n\n  const hexedCode = hexContract(contractCode);\n  const args = [name, hexedCode];\n  // Set roles\n  let ixProposer = to;\n  let ixPayer = to;\n  let ixSigners = [to];\n\n  if (payer) {\n    ixPayer = payer;\n    ixProposer = proposer || payer;\n  }\n\n  return sendTransaction({\n    payer: ixPayer,\n    proposer: ixProposer,\n    signers: ixSigners,\n    code: template,\n    args,\n  });\n};\n\nexport const updateContract = async (props) => {\n  return deployContract({ ...props, update: true });\n};\n"],"names":["DEPLOYED_CONTRACTS","emulator","FlowToken","FungibleToken","testnet","LockedTokens","StakingProxy","mainnet","ACCESS_NODES","getEnvironment","config","get","env","setEnvironment","networkName","options","network","toLowerCase","Error","port","endpoint","portBased","accessNode","put","capitalizeFirstLetter","input","first","split","toUpperCase","slice","underscoreToCamelCase","text","replace","map","word","i","join","trimAndSplit","trimWith","splitBy","getSplitCharacter","indexOf","collapseSpaces","readFile","path","fs","readFileSync","writeFile","data","targetDir","dirname","mkdirSync","recursive","writeFileSync","encoding","clearPath","rmdirSync","getFilesList","dir","promises","readdir","withFileTypes","dirents","Promise","all","dirent","res","resolve","name","isDirectory","files","flat","sansExtension","fileName","generateExports","template","entities","currentFolder","reduce","acc","entity","folders","push","folderNames","camelCased","contractPragma","isFile","filePath","includes","contracts","packageData","code","props","printWidth","endOfLine","semi","useTabs","singleQuote","trailingComma","tabWidth","prettify","prettier","format","parser","plugins","parserBabel","getPairs","line","item","filter","length","collect","contract","address","extractImports","missingImports","addressMap","importsList","missing","key","Object","prototype","hasOwnProperty","call","report","list","prefix","errorMessage","console","error","reportMissingImports","REGEXP_IMPORT","replaceImportAddresses","byName","match","imp","_","Function","CONTRACT","TRANSACTION","SCRIPT","extract","keyWord","target","RegExp","exec","extractSigners","extractScriptArguments","extractTransactionArguments","extractContractName","singleLine","matches","getTemplateInfo","test","signers","args","type","contractName","wrongType","isArray","clearType","startsWith","endsWith","isDictionary","isComplexType","splitArgs","pair","argType","getDictionaryTypes","getArrayType","reportArguments","found","required","reportMissing","itemType","resolveBasicType","t","Optional","raw","resolveType","arrayType","finalType","Array","mapArgument","value","resolvedType","fixedType","isBasicNumType","isString","isCharacter","isBoolean","isBasicType","fcl","arg","isFixedNumType","isNaN","parseFloat","msg","throwTypeError","toFixed","isAddress","prefixedAddress","sansPrefix","keyType","valueType","finalValue","keys","resolvedValue","resolvedKeyType","resolvedValueType","Dictionary","mapArguments","schema","values","mapped","xform","asArgument","mapValuesToCode","TEMP_REPO_FOLDER","process","cwd","clean","existsSync","processGitRepo","output","branch","cliOptions","git","simpleGit","baseDir","binary","fetchUrl","inputBits","owner","repo","getFetchUrl","log","clone","tempGit","branchList","getRemotes","remotes","branches","mappedRemotes","suffix","getBranchesList","params","url","part","index","folderPath","getParamsFromUrl","checkout","processFolder","splitCharacter","fullBasePath","fileList","packages","pathPackages","file","ixDependency","dependency","templateInfo","argsAmount","Handlebars","templates","script","assetName","transaction","signersAmount","templateFolder","package","body","recover","result","e","then","prepareInteraction","limit","ixCode","ixLimit","ix","arr","convert","unwrap","rawArgs","resolveArguments","proposer","payer","ixSigners","ixProposer","authorizations","send","executeScript","response","decode","message","sendTransaction","waitForSeal","tx","onceSealed","txResult","deployContract","to","update","contractCode","hexedCode","Buffer","from","toString","ixPayer","updateContract"],"mappings":"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"}